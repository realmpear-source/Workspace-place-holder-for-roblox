-- ========== SERVICES ==========
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local localPlayer = Players.LocalPlayer

-- ========== CONNECTION MANAGER ==========
local ConnectionManager = {}
ConnectionManager.__index = ConnectionManager

function ConnectionManager.new()
    return setmetatable({
        _connections = {}
    }, ConnectionManager)
end

function ConnectionManager:Add(connection)
    if connection then
        table.insert(self._connections, connection)
    end
    return connection
end

function ConnectionManager:DisconnectAll()
    for _, connection in ipairs(self._connections) do
        if typeof(connection) == "RBXScriptConnection" then
            connection:Disconnect()
        end
    end
    self._connections = {}
end

function ConnectionManager:Destroy()
    self:DisconnectAll()
end

-- ========== CONFIGURATION ==========
local COLORS = {
    survivor = Color3.fromRGB(0, 255, 255),
    killer = Color3.fromRGB(255, 100, 100),
    item = Color3.fromRGB(255, 255, 0),
    generator = Color3.fromRGB(50, 255, 50),
    minion = Color3.fromRGB(170, 0, 255),
    survivorAbility = Color3.fromRGB(255, 165, 0),
    killerAbility = Color3.fromRGB(255, 50, 150)
}

local OBJECT_NAMES = {
    items = {"Medkit", "BloxyCola"},
    minions = {"PizzaDeliveryRig", "1x1x1x1Zombie", "Mafia1", "Mafia2", "Mafia3", "Mafia4", "BlueGuy", "RedGuy", "PurpleGuy", "GreenGuy"},
    survivorAbilities = {"SubspaceTripmine", "pizza"},
    killerAbilities = {"Swords", "Shockwave", "Voidstar", "HumanoidRootProjectile"}
}

local SETTINGS = {
    Keybind = Enum.KeyCode.X,
    GenTime = 2.5,
    MaxAttempts = 1,
    AutoFix = false,
    AutoFixDelay = 1,
    HighlightRefreshRate = 1
}

local ESP_SETTINGS = {
    players = true,
    items = true,
    generators = true,
    survivorAbilities = true,
    killerAbilities = true,
    minions = true
}

-- ========== STATE MANAGEMENT ==========
local State = {
    activeHighlights = setmetatable({}, {__mode = "v"}),
    mainConnections = ConnectionManager.new(),
    highlightConnections = ConnectionManager.new(),
    characterDied = false,
    active = false,
    currentGenerator = nil,
    highlightEnabled = true,
    lastHighlightUpdate = 0,
    autoFixRunning = false
}

-- ========== UTILITY FUNCTIONS ==========
local function safeCall(func, errorMessage)
    local success, result = pcall(func)
    if not success then
        warn(errorMessage or "Safe call error:", result)
        return nil
    end
    return result
end

local function waitForLocalPlayer(timeout)
    if localPlayer then return true end
    
    local startTime = os.clock()
    timeout = timeout or 10
    local connection
    local playerFound = false
    
    connection = Players:GetPropertyChangedSignal("LocalPlayer"):Connect(function()
        if Players.LocalPlayer then
            playerFound = true
            localPlayer = Players.LocalPlayer
            if connection then 
                connection:Disconnect() 
            end
        end
    end)
    
    while os.clock() - startTime < timeout and not playerFound do
        task.wait(0.1)
    end
    
    return playerFound
end

local function isPlayerAlive()
    if State.characterDied then return false end
    
    local character = localPlayer.Character
    local humanoid = character and character:FindFirstChildOfClass("Humanoid")
    
    return humanoid and humanoid.Health > 0
end

-- ========== HIGHLIGHT MANAGEMENT ==========
local function cleanupHighlight(parent)
    local highlight = State.activeHighlights[parent]
    if highlight and highlight.Parent then
        highlight:Destroy()
    end
    State.activeHighlights[parent] = nil
end

local function clearAllHighlights()
    for parent, highlight in pairs(State.activeHighlights) do
        if highlight and highlight.Parent then
            highlight:Destroy()
        end
    end
    table.clear(State.activeHighlights)
end

local function createHighlight(parent, color)
    if not parent or not parent.Parent or State.activeHighlights[parent] then 
        return nil 
    end
    
    return safeCall(function()
        local highlight = Instance.new("Highlight")
        highlight.FillTransparency = 1
        highlight.OutlineColor = color
        highlight.OutlineTransparency = 0.3
        highlight.Parent = parent
        
        State.activeHighlights[parent] = highlight
        
        -- Cleanup when parent is destroyed
        local ancestryConnection
        ancestryConnection = parent.AncestryChanged:Connect(function(_, newParent)
            if newParent == nil then
                cleanupHighlight(parent)
                if ancestryConnection then
                    ancestryConnection:Disconnect()
                end
            end
        end)
        
        return highlight
    end, "Failed to create highlight for: " .. tostring(parent))
end

-- ========== OBJECT VALIDATION ==========
local function isValidObject(obj)
    return obj and (obj:IsA("Model") or obj:IsA("Part") or obj:IsA("BasePart"))
end

local function setupCharacterTracking(character)
    if not character or not character:IsA("Model") then return end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    
    -- Track health changes
    humanoid.HealthChanged:Connect(function(health)
        if health <= 0 then
            cleanupHighlight(character)
        end
    end)
    
    -- Track destruction
    character.AncestryChanged:Connect(function(_, newParent)
        if newParent == nil then
            cleanupHighlight(character)
        end
    end)
end

-- ========== OBJECT SCANNERS ==========
local function processObjectCollection(names, color, conditionCheck)
    conditionCheck = conditionCheck or function() return true end
    
    -- Process existing objects
    for _, obj in ipairs(workspace:GetDescendants()) do
        if isValidObject(obj) and names[obj.Name] and conditionCheck(obj) then
            createHighlight(obj, color)
        end
    end
    
    -- Listen for new objects
    State.highlightConnections:Add(workspace.DescendantAdded:Connect(function(descendant)
        if isValidObject(descendant) and names[descendant.Name] and conditionCheck(descendant) then
            createHighlight(descendant, color)
        end
    end))
end

local function highlightPlayers()
    if not ESP_SETTINGS.players then return end
    
    local playersFolder = workspace:FindFirstChild("Players")
    if not playersFolder then return end
    
    local function processPlayerGroup(group, color)
        if not group then return end
        
        for _, playerModel in ipairs(group:GetChildren()) do
            if playerModel:IsA("Model") then
                createHighlight(playerModel, color)
                setupCharacterTracking(playerModel)
            end
        end
        
        State.highlightConnections:Add(group.ChildAdded:Connect(function(child)
            if child:IsA("Model") then
                createHighlight(child, color)
                setupCharacterTracking(child)
            end
        end))
    end
    
    processPlayerGroup(playersFolder:FindFirstChild("Survivors"), COLORS.survivor)
    processPlayerGroup(playersFolder:FindFirstChild("Killers"), COLORS.killer)
end

local function highlightItems()
    if not ESP_SETTINGS.items then return end
    
    local itemMap = {}
    for _, name in ipairs(OBJECT_NAMES.items) do
        itemMap[name] = true
    end
    
    processObjectCollection(itemMap, COLORS.item)
end

local function highlightMinions()
    if not ESP_SETTINGS.minions then return end
    
    local minionMap = {}
    for _, name in ipairs(OBJECT_NAMES.minions) do
        minionMap[name] = true
    end
    
    processObjectCollection(minionMap, COLORS.minion)
end

local function highlightSurvivorAbilities()
    if not ESP_SETTINGS.survivorAbilities then return end
    
    local abilityMap = {}
    for _, name in ipairs(OBJECT_NAMES.survivorAbilities) do
        abilityMap[name] = true
    end
    
    processObjectCollection(abilityMap, COLORS.survivorAbility)
end

local function highlightKillerAbilities()
    if not ESP_SETTINGS.killerAbilities then return end
    
    local abilityMap = {}
    for _, name in ipairs(OBJECT_NAMES.killerAbilities) do
        abilityMap[name] = true
    end
    
    processObjectCollection(abilityMap, COLORS.killerAbility)
end

local function highlightGenerators()
    if not ESP_SETTINGS.generators then return end
    
    local mapFolder = workspace:FindFirstChild("Map")
    local ingame = mapFolder and mapFolder:FindFirstChild("Ingame")
    local generators = ingame and ingame:FindFirstChild("Map")
    
    if not generators then return end
    
    local function isGeneratorValid(generator)
        if not generator:IsA("Model") then return false end
        local progress = generator:FindFirstChild("Progress")
        return progress and progress.Value < 100
    end
    
    -- Process existing generators
    for _, gen in ipairs(generators:GetChildren()) do
        if gen.Name == "Generator" and isGeneratorValid(gen) then
            createHighlight(gen, COLORS.generator)
        end
    end
    
    -- Listen for new generators
    State.highlightConnections:Add(generators.ChildAdded:Connect(function(child)
        if child.Name == "Generator" and isGeneratorValid(child) then
            createHighlight(child, COLORS.generator)
        end
    end))
end

-- ========== SCAN MANAGEMENT ==========
local function rescanHighlights()
    if not State.highlightEnabled then return end
    
    clearAllHighlights()
    State.highlightConnections:DisconnectAll()
    
    highlightPlayers()
    highlightItems()
    highlightMinions()
    highlightSurvivorAbilities()
    highlightKillerAbilities()
    highlightGenerators()
end

local function toggleHighlights()
    State.highlightEnabled = not State.highlightEnabled
    
    if State.highlightEnabled then
        rescanHighlights()
    else
        clearAllHighlights()
        State.highlightConnections:DisconnectAll()
    end
end

local function updateGeneratorHighlights()
    if not State.highlightEnabled then return end
    
    for parent, highlight in pairs(State.activeHighlights) do
        if parent and parent.Parent and parent.Name == "Generator" then
            local progress = parent:FindFirstChild("Progress")
            if progress and progress.Value >= 100 then
                cleanupHighlight(parent)
            end
        end
    end
end

-- ========== GENERATOR REPAIR SYSTEM ==========
local function validateGenerator(generator)
    if not generator or not generator.Parent then return false end
    
    return generator:FindFirstChild("Progress") and
           generator:FindFirstChild("Main") and
           generator.Main:FindFirstChild("Prompt") and
           generator:FindFirstChild("Remotes") and
           generator.Remotes:FindFirstChild("RE")
end

local function getClosestGenerator()
    if not isPlayerAlive() then return nil end
    
    local character = localPlayer.Character
    local rootPart = character and character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return nil end
    
    local closest = nil
    local minDistance = math.huge
    
    local map = workspace:FindFirstChild("Map")
    local ingame = map and map:FindFirstChild("Ingame")
    local generators = ingame and ingame:FindFirstChild("Map")
    
    if not generators then return nil end
    
    for _, generator in ipairs(generators:GetDescendants()) do
        if generator.Name == "Generator" and validateGenerator(generator) then
            local progress = generator.Progress.Value
            if progress < 100 then
                local distance = (generator:GetPivot().Position - rootPart.Position).Magnitude
                if distance < minDistance then
                    minDistance = distance
                    closest = generator
                end
            end
        end
    end
    
    return closest
end

local function attemptFixGenerator()
    if State.active or not isPlayerAlive() then return end
    
    State.active = true
    local generator = getClosestGenerator()
    
    if not generator then
        State.active = false
        return
    end
    
    State.currentGenerator = generator
    local prompt = generator.Main.Prompt
    
    -- Activate prompt first
    for _ = 1, 3 do
        if not State.active or not isPlayerAlive() then break end
        if prompt and prompt.Parent then
            fireproximityprompt(prompt, 1)
        end
        task.wait(0.1)
    end
    
    -- Attempt repairs
    for i = 1, SETTINGS.MaxAttempts do
        if not State.active or not isPlayerAlive() or not validateGenerator(generator) or generator.Progress.Value >= 100 then 
            break 
        end
        
        safeCall(function()
            generator.Remotes.RE:FireServer()
        end, "Generator repair failed")
        
        if i < SETTINGS.MaxAttempts and generator.Progress.Value < 100 then
            task.wait(SETTINGS.GenTime)
        end
    end
    
    State.active = false
    State.currentGenerator = nil
end

local function autoFixLoop()
    if State.autoFixRunning then return end
    
    State.autoFixRunning = true
    
    while SETTINGS.AutoFix and State.autoFixRunning do
        if not State.active and isPlayerAlive() then
            local generator = getClosestGenerator()
            if generator then
                attemptFixGenerator()
            end
        end
        task.wait(SETTINGS.AutoFixDelay)
    end
    
    State.autoFixRunning = false
end

-- ========== AUTO POPUP SYSTEM ==========
local function handleAutoPopups()
    while true do
        local playerGui = localPlayer:FindFirstChild("PlayerGui")
        local temporaryUI = playerGui and playerGui:FindFirstChild("TemporaryUI")
        
        if temporaryUI then
            for _, popup in ipairs(temporaryUI:GetChildren()) do
                if popup:IsA("Frame") and popup.Name == "1x1x1x1Popup" then
                    local centerX = popup.AbsolutePosition.X + (popup.AbsoluteSize.X / 2)
                    local centerY = popup.AbsolutePosition.Y + (popup.AbsoluteSize.Y / 2) + 50
                    
                    VirtualInputManager:SendMouseButtonEvent(centerX, centerY, 0, true, playerGui, 1)
                    VirtualInputManager:SendMouseButtonEvent(centerX, centerY, 0, false, playerGui, 1)
                end
            end
        end
        task.wait(0.1)
    end
end

-- ========== EVENT HANDLERS ==========
local function onCharacterDeath()
    State.characterDied = true
    State.active = false
    State.currentGenerator = nil
    clearAllHighlights()
end

local function onCharacterAdded(character)
    State.characterDied = false
    
    local humanoid = character:WaitForChild("Humanoid", 5)
    if humanoid then
        humanoid.Died:Connect(onCharacterDeath)
    end
    
    task.wait(1)
    
    if State.highlightEnabled then
        rescanHighlights()
    end
end

-- ========== INPUT HANDLING ==========
local function setupInputHandlers()
    -- Generator repair keybind
    if not SETTINGS.AutoFix then
        State.mainConnections:Add(UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if gameProcessed or State.characterDied or SETTINGS.AutoFix then return end
            
            if input.KeyCode == SETTINGS.Keybind then
                task.spawn(attemptFixGenerator)
            end
        end))
    end
    
    -- Toggle highlights keybind
    State.mainConnections:Add(UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed and input.KeyCode == Enum.KeyCode.P then
            toggleHighlights()
        end
    end))
end

-- ========== INITIALIZATION ==========
local function initialize()
    if not waitForLocalPlayer() then
        warn("Failed to initialize: Local player not found")
        return false
    end
    
    -- Setup input handlers
    setupInputHandlers()
    
    -- Setup character tracking
    if localPlayer.Character then
        local humanoid = localPlayer.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.Died:Connect(onCharacterDeath)
        end
    end
    
    State.mainConnections:Add(localPlayer.CharacterAdded:Connect(onCharacterAdded))
    
    -- Setup highlight updates
    State.mainConnections:Add(RunService.Heartbeat:Connect(function()
        if State.highlightEnabled and os.clock() - State.lastHighlightUpdate > SETTINGS.HighlightRefreshRate then
            updateGeneratorHighlights()
            State.lastHighlightUpdate = os.clock()
        end
    end))
    
    -- Start auto systems
    if SETTINGS.AutoFix then
        task.spawn(autoFixLoop)
    end
    
    task.spawn(handleAutoPopups)
    
    -- Initial highlight scan
    if State.highlightEnabled then
        rescanHighlights()
    end
    
    return true
end

local function cleanup()
    State.active = false
    State.currentGenerator = nil
    State.autoFixRunning = false
    
    State.mainConnections:Destroy()
    State.highlightConnections:DisconnectAll()
    clearAllHighlights()
end

-- ========== MAIN EXECUTION ==========
local success, err = pcall(initialize)
if not success then
    warn("Initialization error: " .. tostring(err))
end

return cleanup
