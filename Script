-- Configuration
local Config = {
    KillAura = {
        Enabled = false,
        Range = math.huge, -- Infinite range
        FOV = 360, -- 360-degree field of view
        AttackFrequency = 0.1, -- Swing every 0.1 seconds
        AttackParts = {"Head", "HumanoidRootPart", "Torso"},
        Keybind = Enum.KeyCode.X
    },
    Safety = {
        UseSafeCalls = true,
        MaxAttempts = 3,
        DelayBetweenAttempts = 0.05
    },
    Performance = {
        MaxZombiesPerCycle = 50, -- Limit to prevent lag
        SkipDistanceCheck = true -- Since range is infinite
    }
}

-- Services
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")

-- Player References
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local root = character:WaitForChild("HumanoidRootPart")

-- Remotes
local gibRemote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Gib")
local sabreRemote = nil

-- Attack timing control
local lastAttackTime = 0
local isAttacking = false

-- Initialize Sabre Remote
local function InitializeSabreRemote()
    local function findSabreRemote()
        local sabreBackpack = player.Backpack:FindFirstChild("Sabre")
        local sabreChar = character:FindFirstChild("Sabre")
        
        if sabreBackpack then
            return sabreBackpack:WaitForChild("RemoteEvent")
        elseif sabreChar then
            return sabreChar:WaitForChild("RemoteEvent")
        end
        return nil
    end
    
    sabreRemote = findSabreRemote()
    if not sabreRemote then
        warn("[KillAura] Sabre not found, will monitor for it...")
        
        -- Monitor for Sabre being equipped
        local function monitorSabre(child)
            if child.Name == "Sabre" then
                task.wait(0.3)
                sabreRemote = child:WaitForChild("RemoteEvent")
                warn("[KillAura] Sabre detected and remote initialized")
            end
        end
        
        character.ChildAdded:Connect(monitorSabre)
        player.Backpack.ChildAdded:Connect(monitorSabre)
        
        -- Check existing items
        for _, child in ipairs(player.Backpack:GetChildren()) do
            monitorSabre(child)
        end
        for _, child in ipairs(character:GetChildren()) do
            monitorSabre(child)
        end
    else
        warn("[KillAura] Sabre remote initialized successfully")
    end
end

-- Safe Call Wrapper with enhanced error recovery
local function SafeCall(func, ...)
    if not Config.Safety.UseSafeCalls then
        return func(...)
    end
    
    local attempts = 0
    local lastError = ""
    local args = {...}
    
    while attempts < Config.Safety.MaxAttempts do
        local success, result = pcall(function()
            return func(unpack(args))
        end)
        
        if success then
            return result
        else
            lastError = result
            attempts += 1
            if attempts < Config.Safety.MaxAttempts then
                task.wait(Config.Safety.DelayBetweenAttempts)
            end
        end
    end
    
    warn("[SafeCall] Failed after", attempts, "attempts. Error:", lastError)
    return nil
end

-- Enhanced zombie finding with workspace scanning
local function GetZombies()
    local zombies = {}
    local count = 0
    
    local function scanFolder(folder)
        if count >= Config.Performance.MaxZombiesPerCycle then
            return
        end
        
        for _, item in ipairs(folder:GetChildren()) do
            if count >= Config.Performance.MaxZombiesPerCycle then
                break
            end
            
            if item:IsA("Model") then
                local folderName = folder.Name
                
                -- Skip non-zombie items in Camera folder (except m_Zombie)
                if folderName == "Camera" and item.Name ~= "m_Zombie" then
                    continue
                end
                
                -- Check if it's a valid target
                local humanoidRootPart = item:FindFirstChild("HumanoidRootPart")
                local humanoid = item:FindFirstChild("Humanoid")
                
                if humanoidRootPart and humanoid and humanoid.Health > 0 then
                    table.insert(zombies, item)
                    count += 1
                end
            elseif item:IsA("Folder") then
                scanFolder(item)
            end
        end
    end
    
    -- Primary scan: Zombies folder
    local zombiesFolder = workspace:FindFirstChild("Zombies")
    if zombiesFolder then
        scanFolder(zombiesFolder)
    end
    
    -- Secondary scan: Look for any remaining zombie-like models
    if count < Config.Performance.MaxZombiesPerCycle then
        for _, model in ipairs(workspace:GetChildren()) do
            if count >= Config.Performance.MaxZombiesPerCycle then
                break
            end
            
            if model:IsA("Model") then
                local humanoidRootPart = model:FindFirstChild("HumanoidRootPart")
                local humanoid = model:FindFirstChild("Humanoid")
                
                -- Check if it's likely a zombie (not already added, has health, not player)
                if humanoidRootPart and humanoid and humanoid.Health > 0 then
                    local isPlayer = Players:GetPlayerFromCharacter(model)
                    local isAlreadyAdded = false
                    
                    for _, z in ipairs(zombies) do
                        if z == model then
                            isAlreadyAdded = true
                            break
                        end
                    end
                    
                    if not isPlayer and not isAlreadyAdded then
                        -- Additional zombie detection heuristics
                        local nameLower = model.Name:lower()
                        if nameLower:find("zombie") or 
                           nameLower:find("infected") or 
                           nameLower:find("walker") or
                           model:FindFirstChild("Zombie") then
                            table.insert(zombies, model)
                            count += 1
                        end
                    end
                end
            end
        end
    end
    
    return zombies
end

-- Check if zombie is within FOV (360 means always true)
local function IsInFOV(zombie)
    if Config.KillAura.FOV >= 360 then
        return true
    end
    
    if not root then return false end
    
    local zombieRoot = zombie:FindFirstChild("HumanoidRootPart")
    if not zombieRoot then return false end
    
    -- Calculate angle between player's look vector and zombie direction
    local directionToZombie = (zombieRoot.Position - root.Position).Unit
    local lookVector = root.CFrame.LookVector
    local angle = math.deg(math.acos(lookVector:Dot(directionToZombie)))
    
    return angle <= (Config.KillAura.FOV / 2)
end

-- Fast attack zombie with 360-degree coverage
local function AttackZombie(zombie)
    if not sabreRemote or not root or isAttacking then 
        return false 
    end
    
    local zombieRoot = zombie:FindFirstChild("HumanoidRootPart")
    if not zombieRoot then return false end
    
    -- Check if zombie has health
    local humanoid = zombie:FindFirstChild("Humanoid")
    if humanoid and humanoid.Health <= 0 then
        return false
    end
    
    -- Check FOV (always true for 360)
    if not IsInFOV(zombie) then
        return false
    end
    
    -- Select attack part
    local attackPart = nil
    local partName = ""
    
    for _, pName in ipairs(Config.KillAura.AttackParts) do
        local part = zombie:FindFirstChild(pName)
        if part then
            attackPart = part
            partName = pName
            break
        end
    end
    
    if not attackPart then
        attackPart = zombieRoot
        partName = "HumanoidRootPart"
    end
    
    -- Calculate hit position with slight randomization for realism
    local hitPos = attackPart.Position + Vector3.new(
        math.random(-0.5, 0.5),
        math.random(-0.5, 0.5),
        math.random(-0.5, 0.5)
    )
    
    local direction = (hitPos - root.Position).Unit
    
    -- Set attacking flag to prevent overlap
    isAttacking = true
    
    -- Execute all attacks in rapid succession
    local attackResults = {
        SafeCall(function()
            sabreRemote:FireServer("Swing", "Over")
        end),
        
        SafeCall(function()
            gibRemote:FireServer(zombie, partName, hitPos, direction)
        end),
        
        SafeCall(function()
            sabreRemote:FireServer("HitZombie", zombie, hitPos, false)
        end)
    }
    
    -- Optional: Extra swing for more damage
    task.wait(0.05)
    SafeCall(function()
        sabreRemote:FireServer("Swing", "Side")
    end)
    
    isAttacking = false
    
    return true
end

-- Multi-target attack system
local function ExecuteKillAura()
    if not Config.KillAura.Enabled or not sabreRemote then 
        return 
    end
    
    -- Rate limiting check
    local currentTime = tick()
    if currentTime - lastAttackTime < Config.KillAura.AttackFrequency then
        return
    end
    
    lastAttackTime = currentTime
    
    local zombies = GetZombies()
    if #zombies == 0 then 
        return 
    end
    
    -- Attack all zombies simultaneously (within limits)
    local attackedCount = 0
    
    for _, zombie in ipairs(zombies) do
        if attackedCount >= Config.Performance.MaxZombiesPerCycle then
            break
        end
        
        -- Attack without distance check (infinite range)
        local success = AttackZombie(zombie)
        if success then
            attackedCount += 1
        end
        
        -- Small delay between individual zombie attacks to prevent server rejection
        if attackedCount > 1 then
            task.wait(0.01)
        end
    end
    
    if attackedCount > 0 then
        warn("[KillAura] Attacked", attackedCount, "zombies")
    end
end

-- Toggle system
local function ToggleKillAura()
    Config.KillAura.Enabled = not Config.KillAura.Enabled
    local status = Config.KillAura.Enabled and "ENABLED" or "DISABLED"
    
    warn("=======================================")
    warn("[KillAura] STATUS: " .. status)
    warn("[KillAura] Range: INFINITE")
    warn("[KillAura] FOV: 360Â°")
    warn("[KillAura] Attack Speed: " .. Config.KillAura.AttackFrequency .. "s")
    warn("[KillAura] Keybind: " .. Config.KillAura.Keybind.Name)
    warn("=======================================")
end

-- Advanced initialization with error recovery
local function Initialize()
    warn("[KillAura] Starting advanced initialization...")
    
    -- Character validation
    if not character:FindFirstChild("Humanoid") then
        character:WaitForChild("Humanoid")
    end
    
    -- Root part validation
    if not root then
        repeat task.wait(0.1) 
            root = character:FindFirstChild("HumanoidRootPart")
        until root
    end
    
    -- Initialize sabre with retry
    local retries = 0
    while not sabreRemote and retries < 5 do
        InitializeSabreRemote()
        if not sabreRemote then
            retries += 1
            warn("[KillAura] Waiting for sabre... Attempt " .. retries)
            task.wait(1)
        end
    end
    
    -- Character respawn handler with debounce
    local respawnConnection
    respawnConnection = player.CharacterAdded:Connect(function(newChar)
        task.wait(0.5) -- Wait for character to fully load
        
        character = newChar
        root = newChar:WaitForChild("HumanoidRootPart")
        
        -- Reinitialize sabre after short delay
        task.wait(1)
        InitializeSabreRemote()
        
        warn("[KillAura] Character respawn handled")
    end)
    
    -- Keybind system with anti-spam
    local lastToggleTime = 0
    UserInputService.InputBegan:Connect(function(input, processed)
        if processed then return end
        
        if input.KeyCode == Config.KillAura.Keybind then
            local currentTime = tick()
            if currentTime - lastToggleTime > 0.5 then -- 0.5 second cooldown for toggling
                ToggleKillAura()
                lastToggleTime = currentTime
            end
        end
    end)
    
    -- Main attack loop
    local mainConnection
    mainConnection = RunService.Heartbeat:Connect(function()
        local success, err = pcall(ExecuteKillAura)
        if not success then
            warn("[KillAura] Error in main loop:", err)
            -- Attempt to recover
            task.wait(0.5)
        end
    end)
    
    warn("[KillAura] Initialization complete!")
    warn("[KillAura] Ready to unleash infinite carnage!")
    warn("[KillAura] Press " .. Config.KillAura.Keybind.Name .. " to begin")
    
    -- Return cleanup function
    return function()
        if mainConnection then
            mainConnection:Disconnect()
        end
        if respawnConnection then
            respawnConnection:Disconnect()
        end
        Config.KillAura.Enabled = false
        warn("[KillAura] Clean shutdown complete")
    end
end

-- Protected initialization with fallback
local cleanupFunction
local initSuccess, initError = pcall(function()
    cleanupFunction = Initialize()
end)

if not initSuccess then
    warn("[KillAura] Critical initialization failed:", initError)
    warn("[KillAura] Attempting fallback initialization...")
    
    -- Fallback simple initialization
    task.wait(2)
    pcall(Initialize)
end

-- Global cleanup on game exit or player leaving
game:GetService("Players").PlayerRemoving:Connect(function(leavingPlayer)
    if leavingPlayer == player then
        if cleanupFunction then
            pcall(cleanupFunction)
        end
    end
end)

-- Auto-recovery system for disconnections
local function SetupAutoRecovery()
    while true do
        task.wait(30) -- Check every 30 seconds
        
        if not sabreRemote and Config.KillAura.Enabled then
            warn("[KillAura] Sabre lost, attempting recovery...")
            InitializeSabreRemote()
        end
        
        if not root and character then
            root = character:FindFirstChild("HumanoidRootPart")
            if root then
                warn("[KillAura] Root part recovered")
            end
        end
    end
end

-- Start auto-recovery in separate thread
coroutine.wrap(SetupAutoRecovery)()
