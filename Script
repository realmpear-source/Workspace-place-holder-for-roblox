
-- Configuration
local Config = {
    KillAura = {
        Enabled = false,
        Keybind = Enum.KeyCode.X,
        AttackParts = {"Head", "HumanoidRootPart"},
        
        -- FOV Settings
        FOV = {
            UseFOV = true,
            MaxFOVAngle = 60, -- Degrees (wider angle = more zombies targeted)
            CheckVisibility = true,
            UseCrosshairTargeting = false -- Prioritize zombies near crosshair
        },
        
        -- Targeting
        MaxTargetsPerFrame = 5,
        SortByAngle = true -- Sort by closest to screen center
    },
    Safety = {
        UseSafeCalls = true,
        MaxAttempts = 3,
        DelayBetweenAttempts = 0.1
    }
}

-- Services
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")

-- Player References
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local root = character:WaitForChild("HumanoidRootPart")

-- Camera Reference
local camera = Workspace.CurrentCamera

-- Remotes
local gibRemote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Gib")
local sabreRemote = nil

-- Initialize Sabre Remote
local function InitializeSabreRemote()
    local function findSabreRemote()
        local sabreBackpack = player.Backpack:FindFirstChild("Sabre")
        local sabreChar = character:FindFirstChild("Sabre")
        
        if sabreBackpack then
            return sabreBackpack:WaitForChild("RemoteEvent")
        elseif sabreChar then
            return sabreChar:WaitForChild("RemoteEvent")
        end
        return nil
    end
    
    sabreRemote = findSabreRemote()
    if not sabreRemote then
        warn("[KillAura] Sabre not found in backpack or character")
        
        -- Listen for Sabre being equipped
        character.ChildAdded:Connect(function(child)
            if child.Name == "Sabre" then
                task.wait(0.5)
                sabreRemote = child:WaitForChild("RemoteEvent")
                warn("[KillAura] Sabre detected and remote initialized")
            end
        end)
        
        player.Backpack.ChildAdded:Connect(function(child)
            if child.Name == "Sabre" then
                sabreRemote = child:WaitForChild("RemoteEvent")
                warn("[KillAura] Sabre detected in backpack")
            end
        end)
    end
end

-- Safe Call Wrapper
local function SafeCall(func, ...)
    if not Config.Safety.UseSafeCalls then
        return func(...)
    end
    
    local attempts = 0
    local lastError = ""
    
    while attempts < Config.Safety.MaxAttempts do
        local success, result = pcall(func, ...)
        
        if success then
            return result
        else
            lastError = result
            attempts += 1
            if attempts < Config.Safety.MaxAttempts then
                task.wait(Config.Safety.DelayBetweenAttempts)
            end
        end
    end
    
    warn("[SafeCall] Failed after", Config.Safety.MaxAttempts, "attempts. Error:", lastError)
    return nil
end

-- Calculate if point is within FOV
local function IsWithinFOV(worldPosition)
    if not camera or not root then return false end
    
    -- Convert world position to screen space
    local screenPoint, onScreen = camera:WorldToViewportPoint(worldPosition)
    
    if not onScreen then
        return false
    end
    
    if Config.FOV.CheckVisibility then
        -- Check for obstacles using raycast
        local rayOrigin = camera.CFrame.Position
        local rayDirection = (worldPosition - rayOrigin).Unit
        local raycastResult = Workspace:Raycast(rayOrigin, rayDirection * 1000, {
            FilterType = Enum.RaycastFilterType.Blacklist,
            FilterDescendantsInstances = {character}
        })
        
        if raycastResult then
            local hitInstance = raycastResult.Instance
            local model = hitInstance:FindFirstAncestorOfClass("Model")
            if not model or not model:FindFirstChild("HumanoidRootPart") then
                return false -- Something is blocking the view
            end
        end
    end
    
    -- Calculate angle from screen center
    local viewportSize = camera.ViewportSize
    local screenCenter = Vector2.new(viewportSize.X / 2, viewportSize.Y / 2)
    local screenPos = Vector2.new(screenPoint.X, screenPoint.Y)
    
    local distanceFromCenter = (screenPos - screenCenter).Magnitude
    local maxDistance = math.min(viewportSize.X, viewportSize.Y) * 0.4
    
    if Config.FOV.UseCrosshairTargeting then
        -- More strict targeting near crosshair
        maxDistance = math.min(viewportSize.X, viewportSize.Y) * 0.2
    end
    
    return distanceFromCenter <= maxDistance
end

-- Calculate FOV angle for sorting
local function CalculateFOVAngle(worldPosition)
    if not camera or not root then return 180 end
    
    local cameraCFrame = camera.CFrame
    local cameraLookVector = cameraCFrame.LookVector
    local directionToTarget = (worldPosition - cameraCFrame.Position).Unit
    
    -- Calculate dot product (cosine of angle)
    local dotProduct = cameraLookVector:Dot(directionToTarget)
    
    -- Convert to degrees
    local angle = math.deg(math.acos(math.clamp(dotProduct, -1, 1)))
    
    return angle
end

-- Find Zombies in Folder Structure
local function GetZombies()
    local zombies = {}
    
    local function scanFolder(folder)
        for _, item in ipairs(folder:GetChildren()) do
            if item:IsA("Model") then
                -- Check for zombie model (excluding Camera folder with m_Zombie exception)
                local folderName = folder.Name
                if folderName == "Camera" and item.Name ~= "m_Zombie" then
                    -- Skip non-zombie items in Camera folder
                    continue
                end
                
                -- Check if it's a zombie (has HumanoidRootPart and likely a zombie)
                local humanoidRootPart = item:FindFirstChild("HumanoidRootPart")
                local humanoid = item:FindFirstChildOfClass("Humanoid")
                
                if humanoidRootPart and humanoid and humanoid.Health > 0 then
                    table.insert(zombies, item)
                end
            elseif item:IsA("Folder") then
                -- Recursively scan subfolders
                scanFolder(item)
            end
        end
    end
    
    -- Start scanning from Workspace
    local zombiesFolder = Workspace:FindFirstChild("Zombies")
    if zombiesFolder then
        scanFolder(zombiesFolder)
    else
        -- Fallback: scan entire workspace for zombie models
        warn("[KillAura] Zombies folder not found, scanning workspace...")
        for _, model in ipairs(Workspace:GetChildren()) do
            if model:IsA("Model") then
                local humanoidRootPart = model:FindFirstChild("HumanoidRootPart")
                local humanoid = model:FindFirstChildOfClass("Humanoid")
                
                if humanoidRootPart and humanoid and humanoid.Health > 0 then
                    -- Basic zombie detection
                    if model.Name:lower():find("zombie") or model:FindFirstChild("Zombie") then
                        table.insert(zombies, model)
                    end
                end
            end
        end
    end
    
    return zombies
end

-- Filter zombies within FOV
local function GetZombiesInFOV(zombies)
    local zombiesInFOV = {}
    
    for _, zombie in ipairs(zombies) do
        local zombieRoot = zombie:FindFirstChild("HumanoidRootPart")
        if zombieRoot then
            if IsWithinFOV(zombieRoot.Position) then
                table.insert(zombiesInFOV, zombie)
            end
        end
    end
    
    return zombiesInFOV
end

-- Sort Zombies by FOV angle (closest to center)
local function SortZombiesByFOVAngle(zombies)
    if #zombies == 0 then return zombies end
    
    if Config.KillAura.SortByAngle then
        table.sort(zombies, function(a, b)
            local aRoot = a:FindFirstChild("HumanoidRootPart")
            local bRoot = b:FindFirstChild("HumanoidRootPart")
            
            if not aRoot then return false end
            if not bRoot then return true end
            
            local angleA = CalculateFOVAngle(aRoot.Position)
            local angleB = CalculateFOVAngle(bRoot.Position)
            
            return angleA < angleB
        end)
    end
    
    -- Limit targets per frame
    if #zombies > Config.KillAura.MaxTargetsPerFrame then
        local limited = {}
        for i = 1, math.min(Config.KillAura.MaxTargetsPerFrame, #zombies) do
            table.insert(limited, zombies[i])
        end
        return limited
    end
    
    return zombies
end

-- Attack Zombie
local function AttackZombie(zombie)
    if not sabreRemote or not root then return false end
    
    local zombieRoot = zombie:FindFirstChild("HumanoidRootPart")
    if not zombieRoot then return false end
    
    -- Try different attack parts
    for _, partName in ipairs(Config.KillAura.AttackParts) do
        local attackPart = zombie:FindFirstChild(partName)
        if attackPart then
            local hitPos = attackPart.Position
            local direction = (hitPos - root.Position).Unit
            
            -- Safe remote calls
            SafeCall(function()
                sabreRemote:FireServer("Swing", "Over")
                gibRemote:FireServer(zombie, partName, hitPos, direction)
                sabreRemote:FireServer("HitZombie", zombie, hitPos, false)
            end)
            
            return true
        end
    end
    
    -- Fallback to root part
    local hitPos = zombieRoot.Position
    local direction = (hitPos - root.Position).Unit
    
    SafeCall(function()
        sabreRemote:FireServer("Swing", "Over")
        gibRemote:FireServer(zombie, "HumanoidRootPart", hitPos, direction)
        sabreRemote:FireServer("HitZombie", zombie, hitPos, false)
    end)
    
    return true
end

-- Main Kill Aura Function
local function ExecuteKillAura()
    if not Config.KillAura.Enabled or not sabreRemote or not camera then return end
    
    local zombies = GetZombies()
    if #zombies == 0 then return end
    
    -- Filter zombies within FOV
    local zombiesInFOV = GetZombiesInFOV(zombies)
    if #zombiesInFOV == 0 then return end
    
    -- Sort by FOV angle and attack
    local targets = SortZombiesByFOVAngle(zombiesInFOV)
    
    for _, zombie in ipairs(targets) do
        AttackZombie(zombie)
    end
end

-- Toggle Kill Aura
local function ToggleKillAura()
    Config.KillAura.Enabled = not Config.KillAura.Enabled
    warn("[KillAura]", Config.KillAura.Enabled and "Enabled" or "Disabled")
    
    if Config.KillAura.Enabled then
        warn("[KillAura] Mode: Infinite Range + FOV Targeting")
        warn("[KillAura] Keybind:", Config.KillAura.Keybind.Name)
        warn("[KillAura] FOV Angle:", Config.FOV.MaxFOVAngle, "degrees")
        warn("[KillAura] Max targets per frame:", Config.KillAura.MaxTargetsPerFrame)
    end
end

-- Initialize
local function Initialize()
    warn("[KillAura] Initializing...")
    warn("[KillAura] Version 2.1 - Infinite Range + FOV Targeting")
    
    -- Wait for character to fully load
    if not character:FindFirstChild("Humanoid") then
        character:WaitForChild("Humanoid")
    end
    
    InitializeSabreRemote()
    
    -- Character respawn handler
    player.CharacterAdded:Connect(function(newChar)
        character = newChar
        root = newChar:WaitForChild("HumanoidRootPart")
        task.wait(1) -- Wait for equipment to load
        InitializeSabreRemote()
    end)
    
    -- Camera reference update
    camera = Workspace.CurrentCamera
    Workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
        camera = Workspace.CurrentCamera
    end)
    
    -- Keybind handler
    UserInputService.InputBegan:Connect(function(input, processed)
        if processed then return end
        
        if input.KeyCode == Config.KillAura.Keybind then
            ToggleKillAura()
        end
    end)
    
    -- Main loop - use RenderStepped for smooth FOV calculations
    local connection
    connection = RunService.RenderStepped:Connect(function()
        if Config.KillAura.Enabled then
            ExecuteKillAura()
        end
    end)
    
    warn("[KillAura] Initialized successfully")
    warn("[KillAura] Press", Config.KillAura.Keybind.Name, "to toggle kill aura")
    
    return connection
end

-- Error handling for initialization
local success, mainConnection = pcall(Initialize)
if not success then
    warn("[KillAura] Initialization failed:", mainConnection)
else
    warn("[KillAura] Running successfully")
end

-- Cleanup on script termination
game:GetService("Players").PlayerRemoving:Connect(function(leavingPlayer)
    if leavingPlayer == player then
        if mainConnection then
            mainConnection:Disconnect()
        end
        warn("[KillAura] Cleaned up")
    end
end)
