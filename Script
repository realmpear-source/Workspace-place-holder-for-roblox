-- CONFIGURATION
local RANGE = 25
local KEYBIND = Enum.KeyCode.X
local WEAPONS = { "Sabre", "Axe" }
local PRIORITY_ZOMBIE_NAME = "BarrelZombie"
local PRIORITY_COLOR = Color3.fromRGB(255, 255, 0) -- Yellow
local UPDATE_INTERVAL = 0.1

-- SERVICES
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

-- GLOBALS
local auraEnabled = false
local player = Players.LocalPlayer
local character, rootPart, humanoid
local zombiesFolder = Workspace:WaitForChild("Zombies")
local gibRemote = game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Gib")
local equippedWeapon, weaponRemote

-- CACHE
local zombieCache = {}
local priorityOutlines = {}
local lastUpdate = tick()
local cleanupConnections = {}

-- INITIALIZE PLAYER
local function initializeCharacter()
    character = player.Character or player.CharacterAdded:Wait()
    rootPart = character:WaitForChild("HumanoidRootPart")
    humanoid = character:WaitForChild("Humanoid")
    zombieCache = {} -- Reset cache on character change
end

initializeCharacter()
player.CharacterAdded:Connect(initializeCharacter)

-- WEAPON MANAGEMENT
local function findWeapon()
    for _, weaponName in ipairs(WEAPONS) do
        local weapon = character:FindFirstChild(weaponName)
        if weapon and weapon:FindFirstChild("RemoteEvent") then
            return weapon, weapon.RemoteEvent
        end
        
        if player.Backpack then
            weapon = player.Backpack:FindFirstChild(weaponName)
            if weapon and weapon:FindFirstChild("RemoteEvent") then
                return weapon, weapon.RemoteEvent
            end
        end
    end
    return nil, nil
end

local function updateWeapon()
    equippedWeapon, weaponRemote = findWeapon()
    return weaponRemote ~= nil
end

-- MONITOR WEAPON CHANGES
local function monitorWeaponChanges()
    local function onChildAdded(child, containerName)
        if table.find(WEAPONS, child.Name) then
            task.wait(0.1)
            updateWeapon()
        end
    end
    
    table.insert(cleanupConnections, player.Backpack.ChildAdded:Connect(function(child)
        onChildAdded(child, "Backpack")
    end))
    
    table.insert(cleanupConnections, character.ChildAdded:Connect(function(child)
        onChildAdded(child, "Character")
    end))
end

-- PRIORITY ZOMBIE HIGHLIGHTING
local function createPriorityOutline(zombie)
    if priorityOutlines[zombie] then return end
    
    local highlight = Instance.new("Highlight")
    highlight.Name = "PriorityOutline"
    highlight.Adornee = zombie
    highlight.FillColor = PRIORITY_COLOR
    highlight.FillTransparency = 0.8
    highlight.OutlineColor = PRIORITY_COLOR
    highlight.OutlineTransparency = 0
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = Workspace
    
    priorityOutlines[zombie] = highlight
    
    -- Cleanup when zombie is removed
    table.insert(cleanupConnections, zombie.AncestryChanged:Connect(function(_, parent)
        if not parent then
            if priorityOutlines[zombie] then
                priorityOutlines[zombie]:Destroy()
                priorityOutlines[zombie] = nil
            end
        end
    end))
end

local function cleanupOutlines()
    for zombie, outline in pairs(priorityOutlines) do
        if not zombie or not zombie.Parent or zombie.Parent ~= zombiesFolder then
            outline:Destroy()
            priorityOutlines[zombie] = nil
        end
    end
end

-- ZOMBIE MANAGEMENT
local function isValidZombie(zombie)
    if not zombie:IsA("Model") then return false end
    if not zombie.Parent then return false end
    
    local humanoidRootPart = zombie:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return false end
    
    if zombie.Parent.Name == "Camera" and zombie.Name ~= "m_Zombie" then
        return false
    end
    
    return true
end

local function cacheZombies()
    if tick() - lastUpdate < 0.5 and next(zombieCache) ~= nil then
        return
    end
    
    zombieCache = {}
    
    for _, zombie in ipairs(zombiesFolder:GetChildren()) do
        if isValidZombie(zombie) then
            local isPriority = zombie.Name == PRIORITY_ZOMBIE_NAME
            local distance = 9999
            
            if rootPart and zombie.HumanoidRootPart then
                distance = (zombie.HumanoidRootPart.Position - rootPart.Position).Magnitude
            end
            
            zombieCache[zombie] = {
                model = zombie,
                root = zombie.HumanoidRootPart,
                distance = distance,
                isPriority = isPriority,
                lastSeen = tick()
            }
            
            if isPriority then
                createPriorityOutline(zombie)
            end
        end
    end
    
    lastUpdate = tick()
    cleanupOutlines()
end

local function getZombiesInRange()
    local zombies = {}
    local priorityZombies = {}
    
    if not rootPart then return zombies, priorityZombies end
    
    cacheZombies()
    
    for zombie, data in pairs(zombieCache) do
        if zombie.Parent and data.root then
            -- Update distance
            data.distance = (data.root.Position - rootPart.Position).Magnitude
            
            if data.distance <= RANGE then
                if data.isPriority then
                    table.insert(priorityZombies, data)
                else
                    table.insert(zombies, data)
                end
            end
        else
            zombieCache[zombie] = nil
        end
    end
    
    -- Sort by distance
    table.sort(priorityZombies, function(a, b)
        return a.distance < b.distance
    end)
    
    table.sort(zombies, function(a, b)
        return a.distance < b.distance
    end)
    
    return zombies, priorityZombies
end

-- FACE LOCKING
local function faceTarget(targetPosition)
    if not rootPart or (humanoid and humanoid.Health <= 0) then
        return
    end
    
    local lookAtPosition = Vector3.new(
        targetPosition.X,
        rootPart.Position.Y,
        targetPosition.Z
    )
    
    rootPart.CFrame = CFrame.new(rootPart.Position, lookAtPosition)
end

local function faceClosestZombie(zombies, priorityZombies)
    if #priorityZombies > 0 then
        faceTarget(priorityZombies[1].root.Position)
    elseif #zombies > 0 then
        faceTarget(zombies[1].root.Position)
    end
end

-- ATTACK SYSTEM
local function attackZombie(zombieData)
    if not weaponRemote or not rootPart then return false end
    
    local head = zombieData.model:FindFirstChild("Head")
    if not head then return false end
    
    local hitPos = head.Position
    local direction = (hitPos - rootPart.Position).Unit
    
    local success = pcall(function()
        weaponRemote:FireServer("Swing", "Over")
        gibRemote:FireServer(zombieData.model, "Head", hitPos, direction)
        weaponRemote:FireServer("HitZombie", zombieData.model, hitPos, false)
    end)
    
    return success
end

local function attackAllZombies(zombies, priorityZombies)
    if #zombies == 0 and #priorityZombies == 0 then return end
    
    -- Attack priority zombies first
    for _, zombieData in ipairs(priorityZombies) do
        attackZombie(zombieData)
    end
    
    -- Attack regular zombies
    for _, zombieData in ipairs(zombies) do
        attackZombie(zombieData)
    end
end

-- MAIN LOOP
local function mainLoop()
    if not updateWeapon() then
        return
    end
    
    if not rootPart or (humanoid and humanoid.Health <= 0) then
        return
    end
    
    local zombies, priorityZombies = getZombiesInRange()
    
    if #zombies > 0 or #priorityZombies > 0 then
        faceClosestZombie(zombies, priorityZombies)
        attackAllZombies(zombies, priorityZombies)
    end
end

-- KEYBIND HANDLER
UserInputService.InputBegan:Connect(function(input, processed)
    if not processed and input.KeyCode == KEYBIND then
        auraEnabled = not auraEnabled
        
        -- Clean outlines when disabled
        if not auraEnabled then
            for _, outline in pairs(priorityOutlines) do
                outline:Destroy()
            end
            priorityOutlines = {}
        end
        
        print("[Kill Aura] " .. (auraEnabled and "ENABLED" or "DISABLED"))
        print("[Kill Aura] Priority target: " .. PRIORITY_ZOMBIE_NAME)
    end
end)

-- SETUP
monitorWeaponChanges()
updateWeapon()

-- CONSOLE STATUS
local statusConnection
local function updateConsoleStatus()
    if auraEnabled then
        local zombies, priorityZombies = getZombiesInRange()
        print(string.format(
            "[Aura Active] Range: %d | Priority: %d/%d | Weapon: %s",
            RANGE,
            #priorityZombies,
            #zombies + #priorityZombies,
            equippedWeapon and equippedWeapon.Name or "None"
        ))
    end
end

-- HEARTBEAT LOOP
local heartbeatConnection
heartbeatConnection = RunService.Heartbeat:Connect(function()
    if auraEnabled then
        mainLoop()
        
        -- Update console every 2 seconds
        if not statusConnection or tick() - lastUpdate >= 2 then
            updateConsoleStatus()
            lastUpdate = tick()
        end
    end
end)

table.insert(cleanupConnections, heartbeatConnection)

-- CLEANUP FUNCTION
local function cleanupScript()
    print("[Kill Aura] Cleaning up...")
    
    -- Disconnect all connections
    for _, connection in ipairs(cleanupConnections) do
        if connection then
            connection:Disconnect()
        end
    end
    
    -- Remove all outlines
    for _, outline in pairs(priorityOutlines) do
        outline:Destroy()
    end
    priorityOutlines = {}
    
    print("[Kill Aura] Cleanup complete")
end

-- AUTO-CLEANUP ON PLAYER LEAVE
local function onPlayerLeaving()
    cleanupScript()
end

table.insert(cleanupConnections, Players.PlayerRemoving:Connect(function(leavingPlayer)
    if leavingPlayer == player then
        onPlayerLeaving()
    end
end))

-- MANUAL CLEANUP HOTKEY (Optional - Alt+X)
UserInputService.InputBegan:Connect(function(input, processed)
    if not processed and input.KeyCode == Enum.KeyCode.X and 
       (UserInputService:IsKeyDown(Enum.KeyCode.LeftAlt) or 
        UserInputService:IsKeyDown(Enum.KeyCode.RightAlt)) then
        cleanupScript()
        print("[Kill Aura] Manual cleanup triggered")
    end
end)

-- INITIALIZATION MESSAGE
print("=======================================")
print("[Kill Aura v2.1] Initialized")
print("=======================================")
print("Keybind: " .. KEYBIND.Name .. " (toggle aura)")
print("Alt+" .. KEYBIND.Name .. " (manual cleanup)")
print("Range: " .. RANGE .. " studs")
print("Priority Target: " .. PRIORITY_ZOMBIE_NAME)
print("Weapons: " .. table.concat(WEAPONS, ", "))
print("=======================================")
