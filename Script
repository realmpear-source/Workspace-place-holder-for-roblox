-- Configuration
local KILL_AURA_RANGE = 30
local KEYBIND = Enum.KeyCode.X
local ATTACK_COOLDOWN = 0.5
local SEARCH_COOLDOWN = 0.1

-- Weapon definitions
local SWING_WEAPONS = {"Pickaxe", "Sabre", "Axe", "OfficersSabre"}
local THRUST_WEAPONS = {"HeavySabre", "Stake", "pike", "Spontoon", "lance"}

local WEAPON_TYPES = {}
for _, weapon in ipairs(SWING_WEAPONS) do
    WEAPON_TYPES[weapon] = "Swing"
end
for _, weapon in ipairs(THRUST_WEAPONS) do
    WEAPON_TYPES[weapon] = "Thrust"
end

-- State management
local auraActive = false
local equippedRemote = nil
local equippedWeaponName = nil
local attackType = nil

-- Services
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")

-- Game objects
local player = Players.LocalPlayer
local zombies = Workspace:WaitForChild("Zombies")

-- Character references (will be updated)
local character, humanoidRootPart, humanoid

-- Initialize character
local function initializeCharacter()
    character = player.Character or player.CharacterAdded:Wait()
    humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    humanoid = character:WaitForChild("Humanoid")
end

-- Safe remote getter
local function getRemote(name, parent)
    local success, remote = pcall(function()
        return parent:WaitForChild(name, 2)
    end)
    return success and remote or nil
end

local gibRemote = getRemote("Gib", game.ReplicatedStorage.Remotes)

-- Weapon management
local function findEquippedWeapon()
    for _, container in ipairs({player.Backpack, character}) do
        for weaponName, weaponAttackType in pairs(WEAPON_TYPES) do
            local weapon = container:FindFirstChild(weaponName)
            if weapon then
                local remote = weapon:FindFirstChild("RemoteEvent")
                if remote then
                    equippedWeaponName = weaponName
                    attackType = weaponAttackType
                    return remote
                end
            end
        end
    end
    return nil
end

local function updateWeapon()
    local newRemote = findEquippedWeapon()
    
    if newRemote ~= equippedRemote then
        equippedRemote = newRemote
        
        if not equippedRemote then
            auraActive = false
            equippedWeaponName = nil
            attackType = nil
            print("Weapon lost. Kill Aura disabled.")
        else
            print("Weapon equipped:", equippedWeaponName, "(" .. attackType .. ")")
        end
    end
end

local function setupWeaponMonitoring(container)
    if not container then return end
    
    container.ChildAdded:Connect(function(child)
        if WEAPON_TYPES[child.Name] then
            task.wait(0.2) -- Wait for RemoteEvent to load
            updateWeapon()
        end
    end)
    
    container.ChildRemoved:Connect(function(child)
        if child.Name == equippedWeaponName then
            updateWeapon()
        end
    end)
end

-- Zombie validation
local function isValidZombie(zombieModel)
    if not zombieModel:IsA("Model") then return false end
    if not zombieModel:FindFirstChild("HumanoidRootPart") then return false end
    
    local parentFolder = zombieModel.Parent
    if parentFolder and parentFolder.Name == "Camera" and zombieModel.Name ~= "m_Zombie" then
        return false
    end
    
    return true
end

-- Get zombies in range
local function getZombiesInRange()
    local zombiesInRange = {}
    
    for _, zombie in ipairs(zombies:GetChildren()) do
        if isValidZombie(zombie) then
            local zombieRoot = zombie.HumanoidRootPart
            local distance = (zombieRoot.Position - humanoidRootPart.Position).Magnitude
            
            if distance <= KILL_AURA_RANGE then
                table.insert(zombiesInRange, zombie)
            end
        end
    end
    
    return zombiesInRange
end

-- Face nearest zombie
local function faceNearestZombie(zombiesList)
    if #zombiesList == 0 then return end
    
    local nearestZombie = nil
    local shortestDistance = math.huge
    
    for _, zombie in ipairs(zombiesList) do
        local distance = (zombie.HumanoidRootPart.Position - humanoidRootPart.Position).Magnitude
        if distance < shortestDistance then
            shortestDistance = distance
            nearestZombie = zombie
        end
    end
    
    if nearestZombie then
        local lookPosition = Vector3.new(
            nearestZombie.HumanoidRootPart.Position.X,
            humanoidRootPart.Position.Y,
            nearestZombie.HumanoidRootPart.Position.Z
        )
        
        character:PivotTo(CFrame.new(humanoidRootPart.Position, lookPosition))
    end
end

-- Attack all zombies in range
local function attackAllZombies()
    local zombiesInRange = getZombiesInRange()
    if #zombiesInRange == 0 then return 0 end
    
    -- Face nearest zombie
    faceNearestZombie(zombiesInRange)
    
    -- Perform attack animation based on weapon type
    if equippedRemote then
        if attackType == "Swing" then
            pcall(function()
                equippedRemote:FireServer("Swing", "Over")
            end)
        elseif attackType == "Thrust" then
            pcall(function()
                equippedRemote:FireServer("Thrust")
            end)
        end
    end
    
    -- Attack each zombie
    local attackCount = 0
    
    for _, zombie in ipairs(zombiesInRange) do
        local head = zombie:FindFirstChild("Head")
        if head and equippedRemote then
            local hitPosition = head.Position
            local direction = (hitPosition - humanoidRootPart.Position).Unit
            
            -- Send hit event
            pcall(function()
                equippedRemote:FireServer("HitZombie", zombie, hitPosition, false)
                
                -- Optional: Send gib event
                if gibRemote then
                    gibRemote:FireServer(zombie, "Head", hitPosition, direction)
                end
                
                attackCount += 1
            end)
        end
    end
    
    return attackCount
end

-- Death handling
local function onCharacterDied()
    auraActive = false
    equippedRemote = nil
    equippedWeaponName = nil
    attackType = nil
    print("Character died. Kill Aura reset.")
end

-- Input handling
UserInputService.InputBegan:Connect(function(input, processed)
    if processed or input.KeyCode ~= KEYBIND then return end
    
    if equippedRemote then
        auraActive = not auraActive
        local status = auraActive and "ACTIVATED" or "DEACTIVATED"
        print("Kill Aura " .. status .. " | Weapon: " .. (equippedWeaponName or "None"))
    else
        print("No weapon equipped! Cannot activate Kill Aura.")
    end
end)

-- Main initialization
initializeCharacter()

-- Set up weapon monitoring
setupWeaponMonitoring(player.Backpack)
setupWeaponMonitoring(character)

-- Initial weapon scan
updateWeapon()

-- Death monitoring
humanoid.Died:Connect(onCharacterDied)

-- Character respawn handling
player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    humanoid = character:WaitForChild("Humanoid")
    
    -- Reset state
    auraActive = false
    equippedRemote = nil
    equippedWeaponName = nil
    attackType = nil
    
    -- Set up monitoring for new character
    setupWeaponMonitoring(character)
    updateWeapon()
    
    -- New death connection
    humanoid.Died:Connect(onCharacterDied)
    
    print("Character respawned. Kill Aura ready.")
end)

-- Main loop
while true do
    if auraActive and humanoid and humanoid.Health > 0 then
        local attackedCount = attackAllZombies()
        
        if attackedCount > 0 then
            task.wait(ATTACK_COOLDOWN)
        else
            task.wait(SEARCH_COOLDOWN)
        end
    else
        task.wait(SEARCH_COOLDOWN)
    end
end
