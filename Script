-- Configuration
local Config = {
    KillAura = {
        Enabled = false,
        Range = 25,
        Keybind = Enum.KeyCode.X,
        AttackParts = {"Head", "HumanoidRootPart"},
        SupportedWeapons = {"Sabre", "Axe"}
    },
    Safety = {
        UseSafeCalls = true,
        MaxAttempts = 3,
        DelayBetweenAttempts = 0.1
    }
}

-- Services
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")

-- Player References
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local root = character:WaitForChild("HumanoidRootPart")

-- Remotes
local gibRemote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Gib")
local weaponRemote = nil
local currentWeapon = nil
local weaponCache = {}

-- Initialize Weapon Remote
local function InitializeWeaponRemote()
    local function findWeaponRemote()
        -- Check character first (equipped weapons)
        for _, weaponName in ipairs(Config.KillAura.SupportedWeapons) do
            local weaponInChar = character:FindFirstChild(weaponName)
            if weaponInChar then
                local remote = weaponInChar:FindFirstChild("RemoteEvent")
                if remote then
                    currentWeapon = weaponName
                    weaponCache[weaponName] = remote
                    return remote
                end
            end
        end
        
        -- Check backpack (unequipped weapons)
        for _, weaponName in ipairs(Config.KillAura.SupportedWeapons) do
            local weaponInBackpack = player.Backpack:FindFirstChild(weaponName)
            if weaponInBackpack then
                local remote = weaponInBackpack:FindFirstChild("RemoteEvent")
                if remote then
                    currentWeapon = weaponName
                    weaponCache[weaponName] = remote
                    return remote
                end
            end
        end
        
        -- Check cache if we found weapons previously
        for weaponName, remote in pairs(weaponCache) do
            if remote and remote.Parent then
                currentWeapon = weaponName
                return remote
            end
        end
        
        return nil
    end
    
    weaponRemote = findWeaponRemote()
    if not weaponRemote then
        warn("[KillAura] No supported weapons found (Sabre/Axe)")
        
        -- Listen for weapons being equipped/added
        local function setupWeaponListeners()
            -- Character equipped weapons
            character.ChildAdded:Connect(function(child)
                for _, weaponName in ipairs(Config.KillAura.SupportedWeapons) do
                    if child.Name == weaponName then
                        task.wait(0.5) -- Wait for remote to be added
                        local remote = child:WaitForChild("RemoteEvent", 2)
                        if remote then
                            weaponCache[weaponName] = remote
                            weaponRemote = remote
                            currentWeapon = weaponName
                            warn("[KillAura]", weaponName, "detected and remote initialized")
                        end
                    end
                end
            end)
            
            -- Backpack weapons
            player.Backpack.ChildAdded:Connect(function(child)
                for _, weaponName in ipairs(Config.KillAura.SupportedWeapons) do
                    if child.Name == weaponName then
                        local remote = child:FindFirstChild("RemoteEvent")
                        if remote then
                            weaponCache[weaponName] = remote
                            -- Don't set as active if not equipped
                            warn("[KillAura]", weaponName, "detected in backpack")
                        end
                    end
                end
            end)
        end
        
        setupWeaponListeners()
    else
        warn("[KillAura] Using", currentWeapon, "as current weapon")
    end
end

-- Update weapon when switching
local function UpdateCurrentWeapon()
    -- Check equipped weapons first
    for _, weaponName in ipairs(Config.KillAura.SupportedWeapons) do
        local weaponInChar = character:FindFirstChild(weaponName)
        if weaponInChar then
            local remote = weaponInChar:FindFirstChild("RemoteEvent")
            if remote then
                if currentWeapon ~= weaponName then
                    currentWeapon = weaponName
                    weaponRemote = remote
                    weaponCache[weaponName] = remote
                    warn("[KillAura] Switched to", weaponName)
                end
                return
            end
        end
    end
    
    -- Check cached weapons
    for weaponName, remote in pairs(weaponCache) do
        if remote and remote.Parent then
            currentWeapon = weaponName
            weaponRemote = remote
            warn("[KillAura] Using cached", weaponName)
            return
        end
    end
    
    -- Fallback to first available remote
    for weaponName, remote in pairs(weaponCache) do
        if remote then
            currentWeapon = weaponName
            weaponRemote = remote
            warn("[KillAura] Fallback to", weaponName)
            return
        end
    end
end

-- Safe Call Wrapper
local function SafeCall(func, ...)
    if not Config.Safety.UseSafeCalls then
        return func(...)
    end
    
    local attempts = 0
    local lastError = ""
    
    while attempts < Config.Safety.MaxAttempts do
        local success, result = pcall(func, ...)
        
        if success then
            return result
        else
            lastError = result
            attempts += 1
            if attempts < Config.Safety.MaxAttempts then
                task.wait(Config.Safety.DelayBetweenAttempts)
            end
        end
    end
    
    warn("[SafeCall] Failed after", Config.Safety.MaxAttempts, "attempts. Error:", lastError)
    return nil
end

-- Find Zombies in Folder Structure
local function GetZombies()
    local zombies = {}
    
    local function scanFolder(folder)
        for _, item in ipairs(folder:GetChildren()) do
            if item:IsA("Model") then
                -- Check for zombie model (excluding Camera folder with m_Zombie exception)
                local folderName = folder.Name
                if folderName == "Camera" and item.Name ~= "m_Zombie" then
                    -- Skip non-zombie items in Camera folder
                    continue
                end
                
                -- Check if it's a zombie (has HumanoidRootPart and likely a zombie)
                local humanoidRootPart = item:FindFirstChild("HumanoidRootPart")
                if humanoidRootPart then
                    table.insert(zombies, item)
                end
            elseif item:IsA("Folder") then
                -- Recursively scan subfolders
                scanFolder(item)
            end
        end
    end
    
    -- Start scanning from Workspace
    local zombiesFolder = workspace:FindFirstChild("Zombies")
    if zombiesFolder then
        scanFolder(zombiesFolder)
    else
        -- Fallback: scan entire workspace for zombie models
        warn("[KillAura] Zombies folder not found, scanning workspace...")
        for _, model in ipairs(workspace:GetChildren()) do
            if model:IsA("Model") and model:FindFirstChild("HumanoidRootPart") then
                -- Basic zombie detection
                if model.Name:lower():find("zombie") or model:FindFirstChild("Zombie") then
                    table.insert(zombies, model)
                end
            end
        end
    end
    
    return zombies
end

-- Distance Check
local function IsInRange(zombie)
    if not root then return false end
    
    local zombieRoot = zombie:FindFirstChild("HumanoidRootPart")
    if not zombieRoot then return false end
    
    local distance = (zombieRoot.Position - root.Position).Magnitude
    return distance <= Config.KillAura.Range
end

-- Sort Zombies by Distance
local function SortZombiesByDistance(zombies)
    if not root then return {} end
    
    table.sort(zombies, function(a, b)
        local aRoot = a:FindFirstChild("HumanoidRootPart")
        local bRoot = b:FindFirstChild("HumanoidRootPart")
        
        if not aRoot then return false end
        if not bRoot then return true end
        
        local distA = (aRoot.Position - root.Position).Magnitude
        local distB = (bRoot.Position - root.Position).Magnitude
        
        return distA < distB
    end)
    
    return zombies
end

-- Weapon-specific attack functions
local function AttackWithSabre(zombie, attackPart, hitPos, direction)
    if weaponRemote then
        SafeCall(function()
            weaponRemote:FireServer("Swing", "Over")
            gibRemote:FireServer(zombie, attackPart.Name, hitPos, direction)
            weaponRemote:FireServer("HitZombie", zombie, hitPos, false)
        end)
        return true
    end
    return false
end

local function AttackWithAxe(zombie, attackPart, hitPos, direction)
    if weaponRemote then
        SafeCall(function()
            -- Axe might have different remote events
            -- Try common patterns
            local success = pcall(function()
                weaponRemote:FireServer("Swing")
            end)
            
            if not success then
                weaponRemote:FireServer("Attack")
            end
            
            gibRemote:FireServer(zombie, attackPart.Name, hitPos, direction)
            
            -- Try hit detection
            pcall(function()
                weaponRemote:FireServer("Hit", zombie, hitPos)
            end)
        end)
        return true
    end
    return false
end

-- Generic attack function that routes to weapon-specific handler
local function AttackZombie(zombie)
    if not weaponRemote or not root then return false end
    
    -- Update current weapon before attacking
    UpdateCurrentWeapon()
    if not weaponRemote then return false end
    
    local zombieRoot = zombie:FindFirstChild("HumanoidRootPart")
    if not zombieRoot then return false end
    
    -- Try different attack parts
    for _, partName in ipairs(Config.KillAura.AttackParts) do
        local attackPart = zombie:FindFirstChild(partName)
        if attackPart then
            local hitPos = attackPart.Position
            local direction = (hitPos - root.Position).Unit
            
            -- Route to weapon-specific attack function
            if currentWeapon == "Sabre" then
                return AttackWithSabre(zombie, attackPart, hitPos, direction)
            elseif currentWeapon == "Axe" then
                return AttackWithAxe(zombie, attackPart, hitPos, direction)
            else
                -- Generic attack for unknown weapons
                SafeCall(function()
                    weaponRemote:FireServer("Swing")
                    gibRemote:FireServer(zombie, partName, hitPos, direction)
                end)
                return true
            end
        end
    end
    
    -- Fallback to root part
    local hitPos = zombieRoot.Position
    local direction = (hitPos - root.Position).Unit
    
    if currentWeapon == "Sabre" then
        return AttackWithSabre(zombie, zombieRoot, hitPos, direction)
    elseif currentWeapon == "Axe" then
        return AttackWithAxe(zombie, zombieRoot, hitPos, direction)
    else
        SafeCall(function()
            weaponRemote:FireServer("Swing")
            gibRemote:FireServer(zombie, "HumanoidRootPart", hitPos, direction)
        end)
        return true
    end
end

-- Main Kill Aura Function
local function ExecuteKillAura()
    if not Config.KillAura.Enabled or not weaponRemote then 
        -- Try to find a weapon if not found
        if Config.KillAura.Enabled and not weaponRemote then
            UpdateCurrentWeapon()
        end
        return 
    end
    
    local zombies = GetZombies()
    local nearbyZombies = {}
    
    -- Filter zombies in range
    for _, zombie in ipairs(zombies) do
        if IsInRange(zombie) then
            table.insert(nearbyZombies, zombie)
        end
    end
    
    if #nearbyZombies == 0 then return end
    
    -- Sort by distance and attack
    nearbyZombies = SortZombiesByDistance(nearbyZombies)
    
    for _, zombie in ipairs(nearbyZombies) do
        AttackZombie(zombie)
    end
end

-- Toggle Kill Aura
local function ToggleKillAura()
    Config.KillAura.Enabled = not Config.KillAura.Enabled
    
    if Config.KillAura.Enabled then
        -- Ensure we have a weapon before enabling
        UpdateCurrentWeapon()
        if weaponRemote then
            warn("[KillAura] Enabled - Using", currentWeapon or "Unknown weapon")
            warn("[KillAura] Range:", Config.KillAura.Range)
            warn("[KillAura] Keybind:", Config.KillAura.Keybind.Name)
        else
            warn("[KillAura] Failed to enable - No weapon found")
            Config.KillAura.Enabled = false
        end
    else
        warn("[KillAura] Disabled")
    end
end

-- Initialize
local function Initialize()
    warn("[KillAura] Initializing...")
    warn("[KillAura] Supported weapons:", table.concat(Config.KillAura.SupportedWeapons, ", "))
    
    -- Wait for character to fully load
    if not character:FindFirstChild("Humanoid") then
        character:WaitForChild("Humanoid")
    end
    
    InitializeWeaponRemote()
    
    -- Character respawn handler
    player.CharacterAdded:Connect(function(newChar)
        character = newChar
        root = newChar:WaitForChild("HumanoidRootPart")
        task.wait(1) -- Wait for equipment to load
        weaponCache = {} -- Clear cache on respawn
        InitializeWeaponRemote()
    end)
    
    -- Keybind handler
    UserInputService.InputBegan:Connect(function(input, processed)
        if processed then return end
        
        if input.KeyCode == Config.KillAura.Keybind then
            ToggleKillAura()
        end
    end)
    
    -- Periodic weapon update (handles weapon switching)
    local weaponUpdateConnection
    weaponUpdateConnection = RunService.Heartbeat:Connect(function(deltaTime)
        -- Update weapon every 0.5 seconds
        if tick() % 0.5 < deltaTime then
            UpdateCurrentWeapon()
        end
    end)
    
    -- Main kill aura loop
    local killAuraConnection
    killAuraConnection = RunService.Heartbeat:Connect(function()
        if Config.KillAura.Enabled then
            ExecuteKillAura()
        end
    end)
    
    warn("[KillAura] Initialized successfully")
    warn("[KillAura] Press", Config.KillAura.Keybind.Name, "to toggle kill aura")
    
    return {
        KillAura = killAuraConnection,
        WeaponUpdate = weaponUpdateConnection
    }
end

-- Error handling for initialization
local success, connections = pcall(Initialize)
if not success then
    warn("[KillAura] Initialization failed:", connections)
else
    warn("[KillAura] Running successfully")
end

-- Cleanup on script termination
game:GetService("Players").PlayerRemoving:Connect(function(leavingPlayer)
    if leavingPlayer == player then
        if connections then
            for _, connection in pairs(connections) do
                if connection then
                    connection:Disconnect()
                end
            end
        end
        warn("[KillAura] Cleaned up")
    end
end)

-- Export configuration for external access (optional)
return {
    Config = Config,
    ToggleKillAura = ToggleKillAura,
    GetCurrentWeapon = function() return currentWeapon end,
    GetWeaponRemote = function() return weaponRemote end
}
